지난 수업 
-db 서버 구축
--> dbms(mariaDB, MySQL) 패키지 설치
-설치 패키지 실행
- DBMS 콘솔에 접속
- DB 관리

APM(Apache, PHP, MariaDB )

서버 사이드 랜더링 vs 클라이언트 사이드 랜더링


---------------------------------------------------

# 과제

---

회사가 리눅스에서 동작하는 온라인 게임을 개발하는 프로젝트를 시작하게 되었다. 

이 프로젝트는 클라이언트와 서버 부분으로 팀을 나누어 진행할 계획이다. 

이에 따라 클라이언트 개발을 하는 프로젝트 A 팀, 서버 개발을 하는 프로젝트 B 팀을 만들고 각 팀별로 세 명씩 배치했다.

(https://prod-files-secure.s3.us-west-2.amazonaws.com/2915bdf0-c509-4cd3-9dd2-873bd81e7d3c/0a7c48cc-96bb-44df-9cdd-74316fc4d0ae/Untitled.png)

과도한 디스크 낭비를 방지하기 위해 각 사용자별로 디스크를 1GB로 제한한다. 

프로젝트 A 팀은 게임 홍보를 위한 웹 사이트를 구축하는 업무를 추가로 담당하고, 프로젝트 B 팀은 파일 송수신을 위해 FTP를 설치한다. 

두 팀 사이의 정보 공유를 위해 NFS를 사용하여 디스크를 공유하고, 윈도를 사용하는 마케팅 팀과의 정보 공유를 위해 삼바를 설치한다.

NFS와 삼바는 두 번째 디스크에 파일 시스템을 설치하여 마운트하고 이 디렉터리를 공유하도록 한다.

**프로젝트 진행을 위해 우선적으로 해야 할 작업은 다음과 같다.**

• 리눅스 설치와 디스크 추가 설치

• 사용자 등록과 디스크 쿼터 설정

• DB와 웹 서버 설정

• 웹 페이지 작성과 게시판 설치

• NFS와 삼바로 디스크 공유

1. **리눅스 시스템을 설치하고 디스크 2 마운트하기**
    - 두 시스템에 모두 리눅스를 설치한다.
    - 리눅스는 디스크 1에 설치하며 자동 파티션을 사용한다.
    - 리눅스 설치가 완료되면 리눅스 1에 디스크 2를 연결하고 파일 시스템을 생성한 후 /nfs 디렉터리에 마운트한다.
    - SSH가 동작하는지 확인하고 윈도에 한글 HPuTTY를 설치하여 윈도에서 터미널로 리눅스에 접속할 수 있도록 한다.
2. **리눅스 시스템에 사용자를 등록하고 사용자 계정에 쿼터 설정하기**
    - [표 16-2]를 참조하여 리눅스 시스템에 사용자 계정과 그룹을 등록하고 디스크 쿼터를 설정
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2915bdf0-c509-4cd3-9dd2-873bd81e7d3c/ea3c55f9-4397-4c6d-952e-042bd3438482/Untitled.png)
    
3. **리눅스 시스템 1에 MariaDB를 설치하고 동작 확인하기**
    - 리눅스 시스템 1에 MariaDB를 설치하고 [표 16-3]의 데이터베이스를 구축
    - 데이터베이스명은 PROJS, 테이블명은 proj_list
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2915bdf0-c509-4cd3-9dd2-873bd81e7d3c/f9da9f23-eb2d-4199-926d-4881620ff43c/Untitled.png)
    
4. **리눅스 시스템 1에 아파치 웹 서버를 설치하고 웹 페이지 작성하기**
    - 리눅스 시스템 1에 아파치 웹 서버를 설치하고 APM을 연동시킨다.
    - 또한 프로젝트를 소개하는 간단한 웹 페이지를 생성하고 게시판을 연결한다.
5. **리눅스 시스템 2에 FTP 서버를 설치하고 동작 확인하기**
    - 리눅스 시스템 2에 FTP 서버를 설치하고 윈도에서 접근할 수 있도록 허용한다.
    - 윈도에는 FTP 클라이언트를 설치한다.
    - 윈도에서 자신의 이력을 간단하게 소개하는 me.txt 파일을 만들고 projb1 계정의 홈 디렉터리에 업로드한다.

**[추가 과제]**

1. **리눅스 시스템 1과 2를 NFS로 연동시키고 디렉터리 공유하기**
    - 리눅스 시스템 1의 /home/ProjShare 디렉터리를 리눅스 시스템 2와 공유한다.
    - 리눅스 시스템 2에도 /home/ProjShare 디렉터리를 만들고 이 디렉터리에 리눅스 시스템 1의 /home/ProjShare 디렉터리를 연결한다.
    - 여기서는 실습의 편의를 위해 /home/ProjShare 디렉터리의 접근 권한을 777로 하지만, 실제 환경에서는 팀 간에 로그인 ID를 공유하여 사용할 수 있도록 하는 것이 바람직하다.
2. **리눅스 시스템 1과 윈도를 삼바로 공유하기**
    - 리눅스 시스템 1에 삼바 서버를 설치하고 /home/ProjShare 디렉터리를 윈도와 공유한다.
    - 삼바 디렉터리에 생성된 파일은 윈도 그리고 리눅스 시스템 1과 리눅스 시스템 2에서 모두 볼 수 있어야 한다.

    -----------------------------------------------------------

    서버: 클라이언트가 통신을 용이하게 하기 위해 만들어짐
    서버 -> 자바언어
      - json 언어 - (중간 매개체 역할, 서버가 클라이언트 둘다 이해할 수 있는 언어)
    클라이언트 -> html 언어(java 언어 해독기)


json 타입은 클라이언트 사이드 랜더링할 때 자주 사용됨

인증방법
- 세션 vs 토큰
- 세션 인증 방식은 사실 stateless하지 않음
- 서버가 여러개가 되면 문제 발생함

토큰 인증 방식은 stateless함
토큰에 유저 정보를 담아놓음
토큰 인증 방식은 우리가 신분증을 발급시켜주는 개념이라 생각하면 됨
토큰에 정보가 있기 때문에 탈취당하면 도용 가능
발행방식이 유출되면 해커가 서버 토큰 발행할 수 있음
- 신분증
username: 홍길동
password: 절대 토큰에 저장X

개발 방식
DDD vs TDD
도메인 주도 개발 vs 테스트 주도 개발

Rest API, Restful
Represontational State Transfer
자원의 이름으로 구분하여 자원의 상태를 주고 받음.
-특징
 > Server - Client가 서로 의존성이 작음
 > % 서버: 자원이 있는 쪽(API)
   클라이언트: 자원을 요청하는 쪽
 > stateless: 서버가 상태를 갖고 있지 않아야 함
   즉, 세션과 같은 정보는 서버가 갖고있지 않는다.
   서버는 각각의 요청을 별개의 것으로 인식하고 처리함
   이전의 요청이 다음 요청 처리에 연관되면 안됨

Restful이 요즘 뜨는 이유
: 서버 부하를 줄이기 위해서 클라이언트 사이드 랜더링 방식이 부각됨에 따라 Restful한 아키텍처가 유행중
1. 공통적인 DTO를 리턴함
2. 응답 데이터의 Mime-type이 동일함
Restful하지 않은 이유
1. CRUD 기능을 Post로만 처리하는 API
2. 엔드포인트에 리소스 or id 외의 정보가 들어가는 경우
  ex. post /student/update X 
  ex. put /student/1 O

mime-type 
- 정의
: 인터넷에서 다양한 유형의 데이터를 식별하기 위한 표준화 방법
Content-type
!! xxx-form-urlencoded: 서버사이드랜더링 할 때 많이 씀
!! application/json: 클라이언트 사이드 랜더링 할 때 많이 씀
multipart/form-data: 파일 업로드 요청시에 많이 씀

디자인 패턴?
싱글톤 패턴
- > 쓰는 이유 : 인스턴스를 하나만 만들고 싶을 때
팩토리 패턴
어탭터 패턴
데코레이터 패턴
탬플릿 메서드 패턴
전략 패턴
프록시 패턴
옵저버 패턴
커맨드 패턴
...

Spring Boot 객체는 모두 싱글톤으로 구성되어 있음
Bean(콩)
@Controller -> @Component
IOC 컨테이너에 등록됨
- : inversion of control
Component Scanner로 Component들을 가져와서
IOC컨테이너에 등록한다
@Controller vs @RestController
               @RestBody + @Controller
@Controller는 view를 반환한다
 뷰 리졸버를 사용해서 view를 반환한다
@RestController는 데이터를 반환한다
 메시지 컨버터를 통해 타입을 변환하여 데이터를 반환한다.
 클라이언트 사이드 랜더링 할 때 사용
뷰 리졸버: 프로젝트 내에 html 파일을 찾아줌
메시지 컨버터: 자바 객체를 JSON타입으로 변환시켜줌

DI (종속성 주입, Dependency Injection)
public class SimpleController {
  private SimpleService service;
  }

public SimpleController(SimpleService service) {
    this.service = service;
  }

setter DI 방식으로 해결 가능

깊은 복사 vs 얕은 복사

얕은복사: 주소값(참조주소)이 같다.
주소값으로 찾아가서 데이터를 가져옴
얕은 복사> 주소값 그대로 들고옴

깊은 복사: 주소값이 다름
 똑같은 값이라도 포인터가 다름

git이 나온 이유
= 분산버전관리
이전에는 중앙버전관리 사용
-- 단점: 협업시 롤백될 수 있음
         중앙 컴퓨터 문제 생기면 업무 중단

버전관리?

git add .
git commit -m ""
git push origin

filter vs interceptor
활동위치 다름
filter는 디스패처 서블릿 가기 전 사용
interceptor는 디스패처 서블릿 타고난 후 사용
filter IOC 컨테이너에 등록되어있지 않음
interceptor는 등록되어있음

FCM(Firebase Cloud Messeging)
토큰 비밀키를 숨겨야 함
환경변수에 비밀키를 등록

node.js vs Spring

spring장점
1. 프레임워크 자체가 엄격해 알 수없는 오류 발생이 적음
2. 자바언어 (객체지향, 타입 시스템)
3. 서브 프로젝트(스프링 시큐리티, 스프링 데이터)
4. 테스트 지원이 좋음

node.js장점
1. 자바스크립트 언어(프론트도 자바스크립트 사용시 개발이 빠름)
2. 비동기처리가 효율적임
3. NPM 라이브러리가 많다
4. 실시간 데이터 처리가 빠름

